#!/usr/bin/env node

/**
 * Zero-Knowledge Proof Generator for Panagram Game
 *
 * This script generates a zero-knowledge proof using the Noir circuit
 * to demonstrate that a user knows the correct answer to a word puzzle
 * without revealing the actual guess or answer.
 *
 * The proof verifies:
 * 1. The user has a valid guess that matches the answer
 * 2. The prover address is legitimate (non-zero)
 * 3. All values are within the BN254 field modulus
 */

import fs from "fs"
import path from "path"
import { ethers } from "ethers"
import { Noir } from "@noir-lang/noir_js"
import { UltraHonkBackend } from "@aztec/bb.js"
import { fileURLToPath } from "url"

// Get __dirname equivalent in ES modules (needed for path resolution)
const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

async function main() {
    // Parse command line arguments
    // Expected format: node generate-proof.mjs <guessHash> <answerHash> <proverAddress>
    const [guessHashHex, answerHashHex, proverAddressDec] =
        process.argv.slice(2)

    // Validate that all required arguments are provided
    if (!guessHashHex || !answerHashHex || !proverAddressDec) {
        console.error(
            "Usage: generate-proof <guessHash> <answerHash> <proverAddress>"
        )
        process.exit(1)
    }

    // Load the compiled Noir circuit from the target directory
    // This JSON file contains the circuit bytecode and ABI generated by 'nargo compile'
    const circuitPath = path.resolve(
        __dirname,
        "../../circuit/target/zk_panagram.json"
    )
    const circuit = JSON.parse(fs.readFileSync(circuitPath, "utf8"))

    // Prepare inputs for the Noir circuit
    // These must match the parameter names in main.nr exactly
    const input = {
        guess_hash: guessHashHex, // Private input: user's guess (as field element)
        answer_hash: answerHashHex, // Public input: expected answer (as field element)
        prover_address: proverAddressDec, // Public input: prover's address (as field element)
    }
    console.error("Field inputs:", input)

    // Initialize the Noir program with the compiled circuit
    const noir = new Noir(circuit)

    // Execute the circuit with the provided inputs to generate a witness
    // The witness contains all intermediate values computed during circuit execution
    const { witness } = await noir.execute(input)

    // Initialize the Ultra Honk backend for proof generation
    // Ultra Honk is a SNARK proving system optimized for efficiency
    const honk = new UltraHonkBackend(circuit.bytecode, { threads: 1 })

    // Generate the actual zero-knowledge proof
    // The 'keccak: true' option ensures compatibility with Ethereum's keccak256 hashing
    const { proof } = await honk.generateProof(witness, {
        keccak: true,
    })

    // Convert the proof bytes to hexadecimal format for Ethereum compatibility
    const hexProof = ethers.hexlify(proof)

    // Log proof information to stderr (for debugging)
    console.error("Proof length:", proof.length)

    // Output the hex-encoded proof to stdout
    // This allows the calling script to capture the proof for contract interaction
    process.stdout.write(hexProof)
}

// Execute the main function and handle any errors
main().catch((err) => {
    console.error(err)
    process.exit(1)
})
